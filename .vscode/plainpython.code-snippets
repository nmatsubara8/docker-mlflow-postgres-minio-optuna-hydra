{
  "n=int(input())": {
    "prefix": "n=",
    "body": "n=int(input())"
  },
  "k=int(input())": {
    "prefix": "k=",
    "body": "k=int(input())"
  },
  "m=int(input())": {
    "prefix": "m=",
    "body": "m=int(input())"
  },
  "s=input()": {
    "prefix": "s=",
    "body": "s=input()"
  },
  "n,m=map(int,input().split())": {
    "prefix": "n,m=",
    "body": "n,m=map(int,input().split())"
  },
  "h,w=map(int,input().split())": {
    "prefix": "h,w=",
    "body": "h,w=map(int,input().split())"
  },
  "a=list(map(int,input().split()))": {
    "prefix": "a=",
    "body": "a=list(map(int,input().split()))"
  },
  "input()": {
    "prefix": "inp",
    "body": "input()"
  },
  "int(input())": {
    "prefix": "ii",
    "body": "int(input())"
  },
  "for i in range(n)": {
    "prefix": "fo",
    "body": "for i in range(n)"
  },
  "for k in range(m):": {
    "prefix": "fom",
    "body": "for j in range(m):"
  },
  "for i in range(w):": {
    "prefix": "fow",
    "body": "for i in range(w)"
  },
  "for i in range(h):": {
    "prefix": "foh",
    "body": "for i in range(h)"
  },
  "for i in range(q):": {
    "prefix": "foq",
    "body": "for i in range(q):"
  },
  "for _": {
    "prefix": "fo_",
    "body": "for _ in range(n):"
  },
  "for _ in range(int(input)):": {
    "prefix": "forii",
    "body": "for _ in range(int(input())):"
  },
  "input().split()": {
    "prefix": "is",
    "body": "input().split()"
  },
  "map(int,input().split())": {
    "prefix": "ma",
    "body": "map(int,input().split())"
  },
  "map(lambda x:int(x)-1,input().split())": {
    "prefix": "mala",
    "body": "map(lambda x:int(x)-1,input().split())"
  },
  "list(map(int,input().split()))": {
    "prefix": "li",
    "body": "list(map(int,input().split()))"
  },
  "lambda x:int(x)-1": {
    "prefix": "la",
    "body": "lambda x:int(x)-1"
  },
  "di=defaultdict()": {
    "prefix": "di=",
    "body": ["from collections import defaultdict", "di=defaultdict()"]
  },
  "edge=": {
    "prefix": "edge=",
    "body": [
      "from collections import defaultdict",
      "edge=defaultdict(list)",
      ""
    ]
  },
  "deque": {
    "prefix": "deque",
    "body": ["from collections import deque", "que=deque()"]
  },
  "c=Counter()": {
    "prefix": "c=",
    "body": ["from collections import Counter", "c=Counter()"]
  },
  "heapq": {
    "prefix": "heap",
    "body": ["from heapq import heapify,heappop,heappush", ""]
  },
  "sys": {
    "prefix": "sys",
    "body": ["import sys", "sys.setrecursionlimit(10**6)"]
  },
  "uf=": {
    "prefix": "uf=",
    "body": "from collections import defaultdict\nclass UnionFind():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.parents = [-1] * n\n\n\tdef find(self, x):\n\t\tif self.parents[x] < 0:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.parents[x] = self.find(self.parents[x])\n\t\t\treturn self.parents[x]\n\n\tdef union(self, x, y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\n\t\tif x == y:\n\t\t\treturn\n\n\t\tif self.parents[x] > self.parents[y]:\n\t\t\tx, y = y, x\n\n\t\tself.parents[x] += self.parents[y]\n\t\tself.parents[y] = x\n\n\tdef size(self, x):\n\t\treturn -self.parents[self.find(x)]\n\n\tdef same(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\n\tdef members(self, x):\n\t\troot = self.find(x)\n\t\treturn [i for i in range(self.n) if self.find(i) == root]\n\n\tdef roots(self):\n\t\treturn [i for i, x in enumerate(self.parents) if x < 0]\n\n\tdef group_count(self):\n\t\treturn len(self.roots())\n\n\tdef all_group_members(self):\n\t\tgroup_members = defaultdict(list)\n\t\tfor member in range(self.n):\n\t\t\tgroup_members[self.find(member)].append(member)\n\t\treturn group_members\n\nuf=UnionFind(n)"
  },
  // https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py
  "SortedSet": {
    "prefix": "ss=",
    "body": "import math\nfrom bisect import bisect_left, bisect_right\nfrom typing import Generic, Iterable, Iterator, TypeVar, Optional, List\nT = TypeVar('T')\n\nclass SortedSet(Generic[T]):\n\tBUCKET_RATIO = 50\n\tREBUILD_RATIO = 170\n\n\tdef _build(self, a=None) -> None:\n\t\t'Evenly divide `a` into buckets.'\n\t\tif a is None: a = list(self)\n\t\tsize = self.size = len(a)\n\t\tbucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n\t\tself.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\t\n\tdef __init__(self, a: Iterable[T] = []) -> None:\n\t\t'Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)'\n\t\ta = list(a)\n\t\tif not all(a[i] < a[i + 1] for i in range(len(a) - 1)):\n\t\t\ta = sorted(set(a))\n\t\tself._build(a)\n\n\tdef __iter__(self) -> Iterator[T]:\n\t\tfor i in self.a:\n\t\t\tfor j in i: yield j\n\n\tdef __reversed__(self) -> Iterator[T]:\n\t\tfor i in reversed(self.a):\n\t\t\tfor j in reversed(i): yield j\n\t\n\tdef __len__(self) -> int:\n\t\treturn self.size\n\t\n\tdef __repr__(self) -> str:\n\t\treturn 'SortedSet' + str(self.a)\n\t\n\tdef __str__(self) -> str:\n\t\ts = str(list(self))\n\t\treturn '{' + s[1 : len(s) - 1] + '}'\n\n\tdef _find_bucket(self, x: T) -> List[T]:\n\t\t'Find the bucket which should contain x. self must not be empty.'\n\t\tfor a in self.a:\n\t\t\tif x <= a[-1]: return a\n\t\treturn a\n\n\tdef __contains__(self, x: T) -> bool:\n\t\tif self.size == 0: return False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\treturn i != len(a) and a[i] == x\n\n\tdef add(self, x: T) -> bool:\n\t\t'Add an element and return True if added. / O(√N)'\n\t\tif self.size == 0:\n\t\t\tself.a = [[x]]\n\t\t\tself.size = 1\n\t\t\treturn True\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\tif i != len(a) and a[i] == x: return False\n\t\ta.insert(i, x)\n\t\tself.size += 1\n\t\tif len(a) > len(self.a) * self.REBUILD_RATIO:\n\t\t\tself._build()\n\t\treturn True\n\n\tdef discard(self, x: T) -> bool:\n\t\t'Remove an element and return True if removed. / O(√N)'\n\t\tif self.size == 0: return False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\tif i == len(a) or a[i] != x: return False\n\t\ta.pop(i)\n\t\tself.size -= 1\n\t\tif len(a) == 0: self._build()\n\t\treturn True\n\t\n\tdef lt(self, x: T) -> Optional[T]:\n\t\t'Find the largest element < x, or None if it does not exist.'\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] < x:\n\t\t\t\treturn a[bisect_left(a, x) - 1]\n\n\tdef le(self, x: T) -> Optional[T]:\n\t\t'Find the largest element <= x, or None if it does not exist.'\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] <= x:\n\t\t\t\treturn a[bisect_right(a, x) - 1]\n\n\tdef gt(self, x: T) -> Optional[T]:\n\t\t'Find the smallest element > x, or None if it does not exist.'\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn a[bisect_right(a, x)]\n\n\tdef ge(self, x: T) -> Optional[T]:\n\t\t'Find the smallest element >= x, or None if it does not exist.'\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn a[bisect_left(a, x)]\n\t\n\tdef __getitem__(self, x: int) -> T:\n\t\t'Return the x-th element, or IndexError if it does not exist.'\n\t\tif x < 0: x += self.size\n\t\tif x < 0: raise IndexError\n\t\tfor a in self.a:\n\t\t\tif x < len(a): return a[x]\n\t\t\tx -= len(a)\n\t\traise IndexError\n\t\n\tdef index(self, x: T) -> int:\n\t\t'Count the number of elements < x.'\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn ans + bisect_left(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\n\n\tdef index_right(self, x: T) -> int:\n\t\t'Count the number of elements <= x.'\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn ans + bisect_right(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\n\n"
  },
  // https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py
  "SortedMultiset": {
    "prefix": "sms=",
    "body": "import math\nfrom bisect import bisect_left, bisect_right, insort\nfrom typing import Generic, Iterable, Iterator, TypeVar, Optional, List\nT = TypeVar('T')\n\nclass SortedMultiset(Generic[T]):\n\tBUCKET_RATIO = 50\n\tREBUILD_RATIO = 170\n\n\tdef _build(self, a=None) -> None:\n\t\t'Evenly divide `a` into buckets.'\n\t\tif a is None: a = list(self)\n\t\tsize = self.size = len(a)\n\t\tbucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))\n\t\tself.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]\n\t\n\tdef __init__(self, a: Iterable[T] = []) -> None:\n\t\t'Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)'\n\t\ta = list(a)\n\t\tif not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):\n\t\t\ta = sorted(a)\n\t\tself._build(a)\n\n\tdef __iter__(self) -> Iterator[T]:\n\t\tfor i in self.a:\n\t\t\tfor j in i: yield j\n\n\tdef __reversed__(self) -> Iterator[T]:\n\t\tfor i in reversed(self.a):\n\t\t\tfor j in reversed(i): yield j\n\t\n\tdef __len__(self) -> int:\n\t\treturn self.size\n\t\n\tdef __repr__(self) -> str:\n\t\treturn 'SortedMultiset' + str(self.a)\n\t\n\tdef __str__(self) -> str:\n\t\ts = str(list(self))\n\t\treturn '{' + s[1 : len(s) - 1] + '}'\n\n\tdef _find_bucket(self, x: T) -> List[T]:\n\t\t'Find the bucket which should contain x. self must not be empty.'\n\t\tfor a in self.a:\n\t\t\tif x <= a[-1]: return a\n\t\treturn a\n\n\tdef __contains__(self, x: T) -> bool:\n\t\tif self.size == 0: return False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\treturn i != len(a) and a[i] == x\n\n\tdef count(self, x: T) -> int:\n\t\t'Count the number of x.'\n\t\treturn self.index_right(x) - self.index(x)\n\n\tdef add(self, x: T) -> None:\n\t\t'Add an element. / O(√N)'\n\t\tif self.size == 0:\n\t\t\tself.a = [[x]]\n\t\t\tself.size = 1\n\t\t\treturn\n\t\ta = self._find_bucket(x)\n\t\tinsort(a, x)\n\t\tself.size += 1\n\t\tif len(a) > len(self.a) * self.REBUILD_RATIO:\n\t\t\tself._build()\n\n\tdef discard(self, x: T) -> bool:\n\t\t'Remove an element and return True if removed. / O(√N)'\n\t\tif self.size == 0: return False\n\t\ta = self._find_bucket(x)\n\t\ti = bisect_left(a, x)\n\t\tif i == len(a) or a[i] != x: return False\n\t\ta.pop(i)\n\t\tself.size -= 1\n\t\tif len(a) == 0: self._build()\n\t\treturn True\n\n\tdef lt(self, x: T) -> Optional[T]:\n\t\t'Find the largest element < x, or None if it does not exist.'\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] < x:\n\t\t\t\treturn a[bisect_left(a, x) - 1]\n\n\tdef le(self, x: T) -> Optional[T]:\n\t\t'Find the largest element <= x, or None if it does not exist.'\n\t\tfor a in reversed(self.a):\n\t\t\tif a[0] <= x:\n\t\t\t\treturn a[bisect_right(a, x) - 1]\n\n\tdef gt(self, x: T) -> Optional[T]:\n\t\t'Find the smallest element > x, or None if it does not exist.'\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn a[bisect_right(a, x)]\n\n\tdef ge(self, x: T) -> Optional[T]:\n\t\t'Find the smallest element >= x, or None if it does not exist.'\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn a[bisect_left(a, x)]\n\t\n\tdef __getitem__(self, x: int) -> T:\n\t\t'Return the x-th element, or IndexError if it does not exist.'\n\t\tif x < 0: x += self.size\n\t\tif x < 0: raise IndexError\n\t\tfor a in self.a:\n\t\t\tif x < len(a): return a[x]\n\t\t\tx -= len(a)\n\t\traise IndexError\n\n\tdef index(self, x: T) -> int:\n\t\t'Count the number of elements < x.'\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] >= x:\n\t\t\t\treturn ans + bisect_left(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\n\n\tdef index_right(self, x: T) -> int:\n\t\t'Count the number of elements <= x.'\n\t\tans = 0\n\t\tfor a in self.a:\n\t\t\tif a[-1] > x:\n\t\t\t\treturn ans + bisect_right(a, x)\n\t\t\tans += len(a)\n\t\treturn ans\n"
  },
  "INF": {
    "prefix": "INF",
    "body": "INF=float('inf')"
  },
  "mod": {
    "prefix": "mod",
    "body": "mod=998244353"
  },
  "MOD": {
    "prefix": "MOD",
    "body": "MOD=1000000007"
  },
  "inside": {
    "prefix": "inside",
    "body": ["def inside(y,x):", "\treturn 0<=y<h and 0<=x<w"]
  },
  "yes": {
    "prefix": "yes",
    "body": "print('Yes')"
  },
  "no": {
    "prefix": "no",
    "body": "print('No')"
  },
  "abc": {
    "prefix": "abc",
    "body": "abc = 'abcdefghijklmnopqrstuvwxyz'"
  },
  "ABC": {
    "prefix": "ABC",
    "body": "ABC = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
  },
  "bit_count": {
    "prefix": "bit_c",
    "body": ["def bit_count(self):", "\treturn bin(self).count('1')"]
  },
  "st=": {
    "prefix": "st=",
    "body": ["# セグメント木\nclass SegTree:\n\t'''\n\tinit(init_val, ide_ele): 配列init_valで初期化 O(N)\n\tupdate(k, x): k番目の値をxに更新 O(logN)\n\tquery(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)\n\t'''\n\tdef __init__(self, init_val, segfunc, ide_ele):\n\t\t'''\n\t\tinit_val: 配列の初期値\n\t\tsegfunc: 区間にしたい操作\n\t\tide_ele: 単位元\n\t\tn: 要素数\n\t\tnum: n以上の最小の2のべき乗\n\t\ttree: セグメント木(1-index)\n\t\t'''\n\t\tn = len(init_val)\n\t\tself.segfunc = segfunc\n\t\tself.ide_ele = ide_ele\n\t\tself.num = 1 << (n - 1).bit_length()\n\t\tself.tree = [ide_ele] * 2 * self.num\n\t\t# 配列の値を葉にセット\n\t\tfor i in range(n):\n\t\t\tself.tree[self.num + i] = init_val[i]\n\t\t# 構築していく\n\t\tfor i in range(self.num - 1, 0, -1):\n\t\t\tself.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n\tdef update(self, k, x):\n\t\t'''\n\t\tk番目の値をxに更新\n\t\tk: index(0-index)\n\t\tx: update value\n\t\t'''\n\t\tk += self.num\n\t\tself.tree[k] = x\n\t\twhile k > 1:\n\t\t\tself.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n\t\t\tk >>= 1\n\n\tdef query(self, l, r):\n\t\t'''\n\t\t[l, r)のsegfuncしたものを得る\n\t\tl: index(0-index)\n\t\tr: index(0-index)\n\t\t'''\n\t\tres = self.ide_ele\n\n\t\tl += self.num\n\t\tr += self.num\n\t\twhile l < r:\n\t\t\tif l & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[l])\n\t\t\t\tl += 1\n\t\t\tif r & 1:\n\t\t\t\tres = self.segfunc(res, self.tree[r - 1])\n\t\t\tl >>= 1\n\t\t\tr >>= 1\n\t\treturn res\n# 最小:min(x,y) 最大:max(x,y) 区間和:x+y 区間積:x*y 最大公約数 math.gcd(x,y)\ndef segfunc(x, y):\n\t# return \nINF=float('inf')\n# 最小:INF 最大:-INF 区間和:0 区間積:1 最大公約数 0\nide_ele = \n"]
  },
  "walk": {
    "prefix": "walk",
    "body": [
      "walk=[",
      "\t(1,0),",
      "\t(-1,0),",
      "\t(0,1),",
      "\t(0,-1),",
      "]",
      ""
    ]
  }
}
